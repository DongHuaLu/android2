package com.example.mutildownloader;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.net.HttpURLConnection;
import java.net.URL;

import android.app.Activity;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.View;
import android.widget.EditText;
import android.widget.ProgressBar;
import android.widget.Toast;

public class MainActivity extends Activity {
	private EditText et;
	private ProgressBar pb;
	public static int threadCount = 5;
	public static int runningThread = 0;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		et = (EditText) findViewById(R.id.et);
		pb = (ProgressBar) findViewById(R.id.pb);
	}

	public void click(View view) {
		String path = et.getText().toString().trim();

		if (TextUtils.isEmpty(path)) {
			Toast.makeText(this, "路径不能为空", 0).show();
		}

		new Thread() {
			public void run() {
				String path = "http://10.200.0.157:8080/1.exe";
				try {
					URL url = new URL(path);
					HttpURLConnection conn = (HttpURLConnection) url
							.openConnection();
					conn.setReadTimeout(5000);
					conn.setRequestMethod("GET");
					int code = conn.getResponseCode();
					if (code == 200) {
						// 服务器返回的数据的长度,其实就是文件的长度
						int length = conn.getContentLength();
						System.out.println("文件长度:" + length);
						// 在客户端本地创建一个length大小的临时文件
						RandomAccessFile raf = new RandomAccessFile(
								"/sdcard/setup.exe", "rwd");
						raf.setLength(length);
						raf.close();
						// 假设三个线程
						// 平均每个线程下载文件的大小
						int blockSize = length / threadCount;

						for (int threadId = 1; threadId <= threadCount; threadId++) {
							int startIndex = (threadId - 1) * blockSize;
							int endIndex = (threadId) * blockSize - 1;
							if (threadId == threadCount) {
								endIndex = length;
							}
							System.out.println("线程" + threadId + "下载:"
									+ startIndex + "------>" + endIndex);
							new DownloadThread(threadId, startIndex, endIndex,
									path).start();
						}
					} else {
						System.out.println("服务器错误");
					}

				} catch (Exception e) {
					e.printStackTrace();
				}


			};
		}.start();

	}
}
